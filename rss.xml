<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[함께 자라기]]></title><description><![CDATA[Code wins arguments.]]></description><link>https://wbluke.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Wed, 09 Mar 2022 07:51:53 GMT</lastBuildDate><item><title><![CDATA[RealMySQL 8.0 - 트랜잭션과 잠금]]></title><description><![CDATA[…]]></description><link>https://wbluke.github.io/database/[realmysql-8.0]-트랜잭션과-잠금/</link><guid isPermaLink="false">https://wbluke.github.io/database/[realmysql-8.0]-트랜잭션과-잠금/</guid><pubDate>Wed, 09 Mar 2022 16:04:39 GMT</pubDate><content:encoded>&lt;h2 id=&quot;개념&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B0%9C%EB%85%90&quot; aria-label=&quot;개념 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;개념&lt;/h2&gt;
&lt;p&gt;잠금은 &lt;strong&gt;동시성을 제어하기 위한 기능&lt;/strong&gt;이고, 트랜잭션은 &lt;strong&gt;데이터 정합성을 보장하기 위한 기능&lt;/strong&gt;이다.&lt;/p&gt;
&lt;p&gt;잠금이 없다면 하나의 데이터를 여러 커넥션에서 동시에 변경할 수 있게 되어, 결과적으로 해당 데이터의 값을 예측할 수가 없게 된다.&lt;br&gt;
즉 잠금은 한 시점에 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.&lt;/p&gt;
&lt;p&gt;트랜잭션이 없다면 작업 단위의 안정성이 사라져 Partial update와 같은 현상이 발생하고, 정합성이 깨지게 된다.&lt;/p&gt;
&lt;h2 id=&quot;트랜잭션&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98&quot; aria-label=&quot;트랜잭션 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;트랜잭션&lt;/h2&gt;
&lt;p&gt;MyISAM, MEMORY 스토리지 엔진은 트랜잭션을 지원하지 않는 반면, InnoDB 스토리지 엔진은 트랜잭션을 지원한다.&lt;br&gt;
트랜잭션이 없다는 것은 Partial update가 발생한다는 것이고, 그만큼 애플리케이션 단에서 꼼꼼하게 정합성 보장을 해줘야 한다는 것을 의미하기 때문에, 트랜잭션은 복잡해 보이지만 오히려 고마운 기능이다.&lt;/p&gt;
&lt;p&gt;트랜잭션은 최소 범위에 적용하는 것이 좋다.&lt;br&gt;
데이터베이스 커넥션은 개수가 제한적이기 때문에, 각 단위 작업이 커넥션을 소유하는 시간이 길어질수록 사용 가능한 커넥션의 수가 줄어든다.&lt;br&gt;
이는 커넥션 획득 지연을 발생시켜 웹 서버, DBMS 서버 모두를 위험하게 만들 수 있다.&lt;/p&gt;
&lt;h2 id=&quot;잠금&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%A0%EA%B8%88&quot; aria-label=&quot;잠금 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;잠금&lt;/h2&gt;
&lt;p&gt;잠금은 크게 MySQL 엔진 레벨과 스토리지 엔진 레벨로 나눌 수 있다.&lt;br&gt;
MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔틴 레벨의 잠금은 스토리지 엔진 간 상호 영향을 주지는 않는다.&lt;/p&gt;
&lt;h3 id=&quot;mysql-엔진의-잠금&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#mysql-%EC%97%94%EC%A7%84%EC%9D%98-%EC%9E%A0%EA%B8%88&quot; aria-label=&quot;mysql 엔진의 잠금 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;MySQL 엔진의 잠금&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;글로벌 락&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;범위가 MySQL 서버 전체로 가장 범위가 크다.&lt;/li&gt;
&lt;li&gt;보통 MyISAM, MEMORY 테이블에서 mysqldump로 백업을 받을 때 사용하는데, InnoDB가 기본 스토리지 엔진이 되면서 가벼운 글로벌 락의 필요성이 생겼다. MySQL 8.0부터 백업 락이 도입되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;테이블 락&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개별 테이블 단위로 설정되는 잠금이다.&lt;/li&gt;
&lt;li&gt;묵시적/명시적 획득이 가능하나 명시적으로 획득할 일은 잘 없다.&lt;/li&gt;
&lt;li&gt;MyISAM, MEMORY 테이블에서 데이터를 변경하면 묵시적으로 발생하는데, InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반 잠금을 제공하기 때문에 묵시적 락은 발생하지 않는다. DDL의 경우에만 테이블 락이 설정된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;네임드 락&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자가 지정한 문자열(String)에 대해 획득하고 반납하는 잠금이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;메타데이터 락&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스 객체(테이블, 뷰)의 이름이나 구조를 변경하는 경우 획득하는 잠금이다.&lt;/li&gt;
&lt;li&gt;명시적으로 획득할 수는 없고, 테이블 명세를 변경하는 경우 자동으로 획득한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;innodb-스토리지-엔진-잠금&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#innodb-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84-%EC%9E%A0%EA%B8%88&quot; aria-label=&quot;innodb 스토리지 엔진 잠금 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;InnoDB 스토리지 엔진 잠금&lt;/h3&gt;
&lt;p&gt;InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과 별개로 레코드 기반의 잠금 방식을 가지고 있어서, MyISAM보다 더 뛰어난 동시성 처리를 제공한다.&lt;br&gt;
하지만 이원화된 잠금으로 인해 이전 버전에서는 MySQL 명령을 이용해 잠금 정보를 조회하기가 쉽지 않았다.&lt;br&gt;
그러나 5.1 버전에서는 &lt;code class=&quot;language-text&quot;&gt;information_schema&lt;/code&gt; 데이터베이스의 &lt;code class=&quot;language-text&quot;&gt;INNODB_TRX&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;INNODB_LOCKS&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;INNODB_LOCK_WAITS&lt;/code&gt; 라는 테이블을 조인해서 조회하면 현재 어떤 트랜잭션이 잠금을 대기하고 있고 해당 잠금을 어느 트랜잭션이 가지고 있는지 확인할 수 있다.&lt;br&gt;
또한 장시간 잠금을 가지고 있는 클라이언트를 찾아 종료시킬 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 846px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 92.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAACd0lEQVQ4y4VUZ5PaMBTk//+WcEngC0czbSihd0wv4QiTHNhgDmPKRqucHRwgp5k3MkJavbe7T57L5QIGh2VZOB6PTti/r9f5ze3n89kVNobH/uDmfr+PTqcjYzAYYDweYzQaYTgcot1uQ1VVNJsNvO22uDeI5QDylnQ6jWq1ivl8jlgshkAgIOdEIoHJZIJuryfXjss+GrUyypUKemKNCZxOJ3eGBFQUBbPZTJZVEZu9Xi/8fr+8aL/fY71eI/D8DGuhIptUEI5EUS6XZbBCFyBvYHbMJpPJoFQqyd8E5gGuEfhbNg1z/ePjkg+Hg+SNmV5v+Hf0e13sZg28/vopqHmBaZq4FtZzrXC323VSfzQ63T7MlzaUgB+fv/qw2eiuy28y1HUdhmE4sd1unXm3e0NP7cCYtW5KtYeLQ/IWCoWQSqUQiUQkn8lkEvF4XM6KUFyJhHB455Bn7HJtL7pU5kFmwlGv1+Hz+RCNRlEoFJwMguEI9tOaOGDepcSVYS6XQz6flyYmIJXNZrNS6VarhXqtBiWRgvU6hbEcY75YQtPWWK1WmE6nkhqXKDQpu4XdwS7hJhra7pjRaIhWW8VJX2LWzOPT0xdBUVBSRcNzr0sUAl7b5t5QByMY39viwOb/JROQ2X0EyEuNcUVwaOF8JcaNKPQfuaOyVJl8FotFySlF4VpSRD6XFZ2yfLfL2bGNHS6VeYgPg20hKsx2IyA7Qtc1BIWtrOPJBXS3ZALSa4vFQmbLruFLQ8BGoyEBN5uN8GdY0GP+NfQjQILwGbJLpG2azaacGVwjBbQQX55Hve4AcmbbaZomM+HM54ozg//9WV87b989wN8b0pENbMaOrQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;InnoDB 스토리지 엔진의 잠금&quot;
        title=&quot;InnoDB 스토리지 엔진의 잠금&quot;
        src=&quot;/static/2f1ebdd007a3fd1dc71c201f9e710b08/5b481/transaction-and-lock-01.png&quot;
        srcset=&quot;/static/2f1ebdd007a3fd1dc71c201f9e710b08/5a46d/transaction-and-lock-01.png 300w,
/static/2f1ebdd007a3fd1dc71c201f9e710b08/0a47e/transaction-and-lock-01.png 600w,
/static/2f1ebdd007a3fd1dc71c201f9e710b08/5b481/transaction-and-lock-01.png 846w&quot;
        sizes=&quot;(max-width: 846px) 100vw, 846px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;레코드 락&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;레코드 자체만을 잠그는 락이며, InnoDB 엔진의 특징은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 것이다. 인덱스가 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.&lt;/li&gt;
&lt;li&gt;보조 인덱스를 이용한 변경 작업은 갭 락과 넥스트 키 락을 걸지만, 프라이머리 키 또는 유니크 인덱스에서의 변경 작업은 레코드 락을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;갭 락&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;레코드와 바로 인접한 레코드 사이의 간격만을 잠근다.&lt;/li&gt;
&lt;li&gt;사이 간격에 새로운 레코드가 생성되는 것을 제어한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;넥스트 키 락&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;레코드 락 + 갭 락&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다. 그런데 의외로 해당 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생하므로, 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 해당 락을 줄이는 것이 좋다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL 8.0에서는 ROW 포맷의 바이너리 로그가 기본 설정으로 변경됐다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자동 증가 락&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;순서대로 증가하는 일련번호 값을 채번하기 위한 테이블 수준의 잠금&lt;/li&gt;
&lt;li&gt;INSERT, REPLACE와 같이 새로운 레코드를 저장하는 쿼리에서만 필요하다.&lt;/li&gt;
&lt;li&gt;트랜잭션과 관계 없이 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL 5.1 이상부터는 &lt;code class=&quot;language-text&quot;&gt;innodb_autoinc_lock_mode&lt;/code&gt;라는 시스템 변수를 이용해 자동 증가 락의 작동 방식을 변경할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;innodb_autoinc_lock_mode=0&lt;/code&gt; : MySQL 5.0과 동일한 잠금 방식으로 모든 INSERT 문장은 자동 증가 락을 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;innodb_autoinc_lock_mode=1&lt;/code&gt; : INSERT되는 레코드의 건수를 정확히 예측할 수 있을 때는 자동 증가 락을 사용하지 않고, 훨씬 가볍고 빠른 래치(뮤텍스)를 이용해 처리한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;innodb_autoinc_lock_mode=2&lt;/code&gt; : 항상 래치(뮤텍스)를 이용해 처리한다. MySQL 8.0의 바이너리 로그 포맷이 기본 ROW 포맷으로 변경되면서 해당 설정도 2가 기본값이 되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그기 때문에, UPDATE 문 등에서 적절한 인덱스가 없다면 테이블을 풀 스캔하면서 모든 레코드를 잠글 수도 있으니 주의해야 한다.&lt;/p&gt;
&lt;p&gt;MySQL 5.1부터는  &lt;code class=&quot;language-text&quot;&gt;information_schema&lt;/code&gt; 데이터베이스의 &lt;code class=&quot;language-text&quot;&gt;INNODB_TRX&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;INNODB_LOCKS&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;INNODB_LOCK_WAITS&lt;/code&gt; 라는 테이블을 사용해 잠금을 확인할 수 있었는데, MySQL 8.0부터는 &lt;code class=&quot;language-text&quot;&gt;information_schema&lt;/code&gt;의 정보들은 조금씩 제거되고 있으며, 대신 &lt;code class=&quot;language-text&quot;&gt;performance_schema&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;data_locks&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;data_lock_waits&lt;/code&gt; 테이블로 대체되고 있다.&lt;/p&gt;
&lt;h2 id=&quot;격리-수준&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80&quot; aria-label=&quot;격리 수준 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;격리 수준&lt;/h2&gt;
&lt;p&gt;격리 수준(isolation level)이란 여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;READ UNCOMMITTED (DIRTY READ)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 트랜잭션의 변경 내용이 커밋이나 롤백 여부에 상관없이 다른 트랜잭션에서 보인다.&lt;/li&gt;
&lt;li&gt;RDBMS 표준에서는 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;READ COMMITTED&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;오라클 DBMS의 기본 격리 수준이다.&lt;/li&gt;
&lt;li&gt;커밋된 데이터만 다른 트랜잭션에서 조회할 수 있다.&lt;/li&gt;
&lt;li&gt;커밋되기 전 데이터를 읽을 수 있는 이유는 해당 테이블이 아니라 언두 영역에 백업된 레코드에서 데이터를 가져오기 때문이다.&lt;/li&gt;
&lt;li&gt;하나의 트랜잭션 내에서 같은 SELECT 쿼리를 실행했을 경우 그 사이에 데이터가 바뀌면 결과가 달라진다. REPEATABLE READ 정합성에 어긋난다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REPEATABLE READ&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL InnoDB 스토리지 엔진의 기본 격리 수준이다.&lt;/li&gt;
&lt;li&gt;변경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경하는데, 이를 MVCC(Multi Version Concurrency Control)이라 한다. REPEATABLE READ와 READ COMMITTED의 차이는 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하느냐에 있다.&lt;/li&gt;
&lt;li&gt;모든 트랜잭션은 순차적으로 증가하는 고유한 트랜잭션 번호를 가지며, 언두 영역의 모든 백업 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함돼 있다. 언두 영역의 데이터는 전체가 보관될 필요는 없고, 특정 트랜잭션 번호의 구간 내에서 백업되기만 하면 된다. 예를 들어 10번이라는 트랜잭션에서 반복적으로 데이터를 조회하는 경우, 트랜잭션 번호가 10번보다 작은 언두 데이터만 조회하도록 하는 것이다.&lt;/li&gt;
&lt;li&gt;SELECT … FOR UPDATE 쿼리는 SELECT 하는 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없어 현재 레코드의 값을 가져와야만 한다. 이렇게 되면 조회할 때마다 값이 보였다 안보였다 할 수 있는데, 이런 현상을 PHANTOM READ(PHANTOM ROW)라고 한다.&lt;/li&gt;
&lt;li&gt;InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 PHANTOM READ가 발생하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SERIALIZABLE&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;읽기 작업도 공유 잠금을 획득해야만 하며, 동시에 다른 트랜잭션은 해당 레코드를 변경할 수 없게 된다.&lt;/li&gt;
&lt;li&gt;PHANTOM READ가 발생하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;뒤로 갈수록 각 트랜잭션 간의 데이터 격리(고립) 정도가 높아지며, 동시 처리 성능도 떨어지는 것이 일반적이다.  &lt;/p&gt;</content:encoded></item><item><title><![CDATA[블로그 이전과 운영 회고]]></title><description><![CDATA[티스토리에서 깃헙으로 22년 맞이 2022년을 맞아 블로그 이전 작업을 시작했다.   2021년 하반기에는 회사 프로젝트도 너무 바쁘고 개인사도 너무 바빠서 블로그는 커녕 개인 공부도 거의 못하고 있었는데, 프로젝트도 끝나고 개인사도 일단락되어서…]]></description><link>https://wbluke.github.io/blog/블로그-이전과-운영-회고/</link><guid isPermaLink="false">https://wbluke.github.io/blog/블로그-이전과-운영-회고/</guid><pubDate>Fri, 18 Feb 2022 08:02:04 GMT</pubDate><content:encoded>&lt;h2 id=&quot;티스토리에서-깃헙으로&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%8B%B0%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%97%90%EC%84%9C-%EA%B9%83%ED%97%99%EC%9C%BC%EB%A1%9C&quot; aria-label=&quot;티스토리에서 깃헙으로 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;티스토리에서 깃헙으로&lt;/h2&gt;
&lt;h3 id=&quot;22년-맞이&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#22%EB%85%84-%EB%A7%9E%EC%9D%B4&quot; aria-label=&quot;22년 맞이 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;22년 맞이&lt;/h3&gt;
&lt;p&gt;2022년을 맞아 블로그 이전 작업을 시작했다.  &lt;/p&gt;
&lt;p&gt;2021년 하반기에는 회사 프로젝트도 너무 바쁘고 개인사도 너무 바빠서 블로그는 커녕 개인 공부도 거의 못하고 있었는데, 프로젝트도 끝나고 개인사도 일단락되어서 1월 한달 간 재정비의 시간을 가졌다.&lt;br&gt;
몸도 마음도 쉬면서 가장 먼저 해야겠다고 생각이 든게 바로 블로그 이전 작업이었다.  &lt;/p&gt;
&lt;h3 id=&quot;이전하는-이유&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B4%EC%A0%84%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0&quot; aria-label=&quot;이전하는 이유 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이전하는 이유&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;기존 블로그인 티스토리 : &lt;a href=&quot;https://wbluke.tistory.com/&quot;&gt;https://wbluke.tistory.com/&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;맨 처음 개발 공부를 시작할 당시에는 Vue.js로 SPA를 띄워서 도메인 붙이고 개인 블로그를 운영했었다. (커뮤니티에서 관련 프로젝트를 했었다.)&lt;br&gt;
나중에 우아한테크코스를 시작하고 본격적으로 개발자 커리어를 쌓으면서, 지속적인 운영의 어려움으로 개인 블로그를 닫고 블로그 플랫폼으로 새롭게 시작하였다.  &lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;첫 블로그 플랫폼으로 티스토리를 선택한 이유는 다음과 같았다.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이미 많은 선배 개발자들이 사용중인 플랫폼&lt;/li&gt;
&lt;li&gt;커스텀 스킨이 많음&lt;/li&gt;
&lt;li&gt;카카오가 티스토리를 인수한 이후 좋은 기능들을 추가하고 개편해줄 것이라는 기대&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;p&gt;그간 티스토리에서 작성한 글이 많지는 않지만, 햇수로 3년 정도 이용해봤는데, 다음과 같은 것들이 불편했다.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;안예쁘다.. (맘에 드는 스킨도 못찾았다.)&lt;/li&gt;
&lt;li&gt;커스터마이징이 쉬울줄 알았지만, 생각보다 쉽지 않았다.&lt;/li&gt;
&lt;li&gt;카카오에서도 여러가지를 시도해보긴 하는 것 같은데 레거시가 커서 그런지 피쳐 속도가 더디다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 988px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 47.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAACmElEQVQoz22Q60uTYRjG379Ii77YdLPsAGWFUYifMjtjigqVqZiJFHaiIsVGtdIsHJWaNo/TedZ5Wq4sa4WaqO34zm2+03b49bRPEd3w47rv58N1XTySyTiCyThGh2kG2w8Zt1chEo0SiUQJhyMxQqGw0DBR8f73/Ln/RdpUwqx5AiwvruByyjidXqFeZNmPVw4ge/z4/UE2NsIElRDBYIhfoUgs8H8jrXnWsS+7mBybZmZ6FvPwFFbLHL2i+fDQNJ9nv+P46cVp97O6IiO7FRGi4PIGkQOb+JRfKJshlA0RJpBk0cYhDJ9oa9FW62h+9Y721h60Nc+pffqajvYhrldqefmihb5eMx6HTxTw8G3RyeyiA9uym/mfHpbsMna3D8m16sIjDkOTgfu3HvCm4a1o+56H1c+o0+kZHZykThgPD04xNf6B1SUnK0sOLB/nGbDYGP+0wMSned5/XcAmvk3aDGwQ9Ckoa+u4V92MD40TkNeZmbAy9+Eray4f3e39GFp6Yrfb7o0xOvWZph4z3WMf6ZueY9Bqw/JlAan22Ut0unrq6/ToG5ppbGyj8U0bbYYeujr7MXYOYOwaEPsA/X1mRoZEU/MMzQYTj/UGXnUM0mqawDhmxSwCpW27j7AlLYuthzLZejCLuAOZxKVmEr//OPGpx8XbCbalnUZ1NBtVei6qjDySMvLZm1VE6rlyDuVc53D+TdIv3uVYSRWSJv0Me/PK2ZV7lV05V0nJvhJjZ7bYz5eTnFOBOvcayXk3SC64w44L91BfeiCoQl1YLahhR/EjUkqfklJWi5Qg2mnOFqE5cxn1qUISTwoV/NHEU8VsP11KwtkyVNkVqHIrSSy4TZIw1RRWoSmqQVOiFUY69lTUs6+ygd9ElHARz2LauAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;회사명패&quot;
        title=&quot;회사명패&quot;
        src=&quot;/static/fa946b9b250d64002c0ed673d61f4bbe/e4900/blog-renewal-01.png&quot;
        srcset=&quot;/static/fa946b9b250d64002c0ed673d61f4bbe/5a46d/blog-renewal-01.png 300w,
/static/fa946b9b250d64002c0ed673d61f4bbe/0a47e/blog-renewal-01.png 600w,
/static/fa946b9b250d64002c0ed673d61f4bbe/e4900/blog-renewal-01.png 988w&quot;
        sizes=&quot;(max-width: 988px) 100vw, 988px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;예뻐야 생산성이 올라간다구요&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;내 회사 명패에 적어놓은 말인데, 주어에 따라 달리 해석할 수 있는 문구이다.&lt;br&gt;
예뻐야 한다는 말이 백엔드 개발자로서는 코드 퀄리티나 시스템 아키텍처를 의미하기도 하고,&lt;br&gt;
실제로 백엔드 개발자지만 개인적으로 눈에 보이는 프론트엔드(화면)가 예쁘면 개발 생산성이 더 향상된다고 느낀다.&lt;br&gt;
&lt;del&gt;하지만 예쁜걸 좋아하는 것과 예쁘게 만들 수 있는 것은 정말 별개의 문제더라..&lt;/del&gt;  &lt;/p&gt;
&lt;p&gt;위 문구를 블로그에도 적용을 해보자면, 일단 내 블로그가 예뻐야 뭔가 생산하고자 하는 의지가 샘솟는다고 해야하나,&lt;br&gt;
이전 티스토리에서는 약간 ‘네가 선택한 플랫폼이니 악으로 깡으로 버텨라’, 하는 마음으로 글을 발행하고 있었던 것 같다.  &lt;/p&gt;
&lt;p&gt;velog, medium, brunch 등 다른 좋은 플랫폼들을 놓고 많은 고민을 했는데, 그래도 내 마음대로 커스터마이징 할 수 있는 깃헙에 올리기로 했다.&lt;br&gt;
물론 옛날처럼 무에서 유를 만들어내기엔 배보다 배꼽이 크기 때문에, 가장 맘에 드는 개츠비(gatsby) starter로 기본 기능을 잡고 차차 커스터마이징을 하기로 했다.&lt;br&gt;
(선택한 starter는 많은 분들이 사용하고 계시는 한재엽님의 &lt;a href=&quot;https://github.com/JaeYeopHan/gatsby-starter-bee&quot;&gt;gatsby-starter-bee&lt;/a&gt;. 감사합니다!)  &lt;/p&gt;
&lt;h2 id=&quot;블로그-운영&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%9A%B4%EC%98%81&quot; aria-label=&quot;블로그 운영 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;블로그 운영&lt;/h2&gt;
&lt;p&gt;블로그 운영 방식에도 조금 변화를 주기로 했다.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;기존 블로그는 경어체를 주로 고집했는데, 이제부터는 기본 문체를 평어체로 두고, 글의 주제에 따라 경어체를 혼용해보려고 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기술 블로그라는 특성 상, 경어체를 쓰니 말꼬리가 너무 어색하거나 문장 간 어미를 억지로 맞춰야하는 느낌이 가끔 있었다.&lt;/li&gt;
&lt;li&gt;아무래도 읽는 사람 입장에서는 경어체가 더 친근하게 다가올 수 있지만, 필요한 정보를 찾으러 방문하는 입장에서는 크게 신경쓰지 않을 것 같았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;글 하나의 분량을 좀 더 light하게&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;너무 완벽한 글을 쓰려고 하니 오히려 키보드를 잡기가 어려운 경우가 있었다. 글 하나의 분량을 줄이고, 짧은 주제로 작성할만한 내용이라면 되도록 발행하려고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주제를 좀 더 다양하게&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;일단 &lt;code class=&quot;language-text&quot;&gt;내 공간&lt;/code&gt;이라는 생각이 드니 다양한 주제로 포스팅을 해보고 싶어졌다. (티스토리는 앞서 말한 이유로 내 공간처럼 편하다는 생각은 잘 안들었다.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최근에 있었던 가장 큰 이슈인 &lt;strong&gt;내집마련기&lt;/strong&gt; 같은거.. 너무 사건사고가 많았는데 다 쓸 수 있을까..&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ulysses 사용 (유료결제)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기존에는 아카이빙/업무일지 용도로 노션을 사용하고, 블로그 글이나 메모 용도로는 베어(bear)를 사용하고 있었다.&lt;/li&gt;
&lt;li&gt;노션은 워낙 무겁기도 하고, 베어는 뭔가 살짝 아쉬운 감이 없지 않아 있었는데 베어의 상위 호환 격인 율리시스(Ulysses)를 보고 1년 유료결제를..🥲 해버렸다.&lt;/li&gt;
&lt;li&gt;아카이빙은 노션으로, 블로그 글과 가벼운 메모는 율리시스를 사용할 예정이다. (근데 너무 예쁘고 좋다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 글 마저도 설 연휴 때 발행하려고 했으나 삽을 뜨고 마무리는 2주나 지나서..ㅋㅋ&lt;br&gt;
유익하고 편안한 블로그 라이프를 이어나가봐야겠다.  &lt;/p&gt;</content:encoded></item><item><title><![CDATA[about]]></title><description><![CDATA[Your name Thank you for reading my resume. If you want to contact me, Please send me an email.]]></description><link>https://wbluke.github.io/resume-en/</link><guid isPermaLink="false">https://wbluke.github.io/resume-en/</guid><pubDate>Sun, 27 Jan 2019 16:21:13 GMT</pubDate><content:encoded>&lt;h1 id=&quot;your-name&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#your-name&quot; aria-label=&quot;your name permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Your name&lt;/h1&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;em&gt;Thank you for reading my resume. If you want to contact me, Please send me an email.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;</content:encoded></item></channel></rss>